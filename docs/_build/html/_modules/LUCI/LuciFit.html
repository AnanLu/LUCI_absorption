
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LUCI.LuciFit &#8212; LUCI-package  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for LUCI.LuciFit</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">Bounds</span>
<span class="kn">from</span> <span class="nn">numdifftools</span> <span class="kn">import</span> <span class="n">Jacobian</span><span class="p">,</span> <span class="n">Hessian</span>
<span class="kn">import</span> <span class="nn">emcee</span>
<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">sps</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">LUCI.LuciFunctions</span> <span class="kn">import</span> <span class="n">Gaussian</span><span class="p">,</span> <span class="n">Sinc</span><span class="p">,</span> <span class="n">SincGauss</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>





<div class="viewcode-block" id="Fit"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit">[docs]</a><span class="k">class</span> <span class="nc">Fit</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that defines the functions necessary for the modelling aspect. This includes</span>
<span class="sd">    the gaussian fit functions, the prior definitions, the log likelihood, and the</span>
<span class="sd">    definition of the posterior (log likelihood times prior).</span>

<span class="sd">    The initial arguments are as follows:</span>
<span class="sd">    Args:</span>

<span class="sd">        spectrum: Spectrum of interest. This should not be the interpolated spectrum nor normalized(numpy array)</span>

<span class="sd">        axis: Wavelength Axis of Spectrum (numpy array)</span>

<span class="sd">        wavenumbers_syn: Wavelength Axis of Reference Spectrum (numpy array)</span>

<span class="sd">        model_type: Type of model (&#39;gaussian&#39;)</span>

<span class="sd">        lines: Lines to fit (must be in line_dict)</span>

<span class="sd">        sigma_rel: Constraints on sigma (must be list)</span>

<span class="sd">        ML_model: Tensorflow/keras machine learning model</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">wavenumbers_syn</span><span class="p">,</span> <span class="n">model_type</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">vel_rel</span><span class="p">,</span> <span class="n">sigma_rel</span><span class="p">,</span>
                 <span class="n">ML_model</span><span class="p">,</span> <span class="n">trans_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">delta_x</span><span class="o">=</span><span class="mi">2943</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">842</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="s1">&#39;SN3&#39;</span><span class="p">,</span> <span class="n">bayes_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">uncertainty_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            spectrum: Spectrum of interest. This should not be the interpolated spectrum nor normalized(numpy array)</span>
<span class="sd">            axis: Wavelength Axis of Spectrum after Redshift Application (numpy array)</span>
<span class="sd">            axis_unshifted: Wavelength Axis of Spectrum after Redshift Application (numpy array)</span>
<span class="sd">            wavenumbers_syn: Wavelength Axis of Reference Spectrum (numpy array)</span>
<span class="sd">            model_type: Type of model (&#39;gaussian&#39;)</span>
<span class="sd">            lines: Lines to fit (must be in line_dict)</span>
<span class="sd">            vel_rel: Constraints on Velocity/Position (must be list; e.x. [1, 2, 1])</span>
<span class="sd">            sigma_rel: Constraints on sigma (must be list; e.x. [1, 2, 1])</span>
<span class="sd">            ML_model: Tensorflow/keras machine learning model</span>
<span class="sd">            trans_filter: Tranmission filter interpolated on unredshifted spectral axis</span>
<span class="sd">            theta: Interferometric angle in degrees (defaults to 11.960 -- this is so that the correction coeff is 1)</span>
<span class="sd">            delta_x: Step Delta</span>
<span class="sd">            n_steps: Number of steps in spectra</span>
<span class="sd">            filter: SITELLE filter (e.x. &#39;SN3&#39;)</span>
<span class="sd">            bayes_bool: Boolean to determine whether or not to run Bayesian analysis (default False)</span>
<span class="sd">            uncertainty_bool: Boolean to determine whether or not to run the uncertainty analysis (default False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Halpha&#39;</span><span class="p">:</span> <span class="mf">656.280</span><span class="p">,</span> <span class="s1">&#39;NII6583&#39;</span><span class="p">:</span> <span class="mf">658.341</span><span class="p">,</span> <span class="s1">&#39;NII6548&#39;</span><span class="p">:</span> <span class="mf">654.803</span><span class="p">,</span>
                          <span class="s1">&#39;SII6716&#39;</span><span class="p">:</span> <span class="mf">671.647</span><span class="p">,</span> <span class="s1">&#39;SII6731&#39;</span><span class="p">:</span> <span class="mf">673.085</span><span class="p">,</span> <span class="s1">&#39;OII3726&#39;</span><span class="p">:</span> <span class="mf">372.603</span><span class="p">,</span>
                          <span class="s1">&#39;OII3729&#39;</span><span class="p">:</span> <span class="mf">372.882</span><span class="p">,</span> <span class="s1">&#39;OIII4959&#39;</span><span class="p">:</span> <span class="mf">495.891</span><span class="p">,</span> <span class="s1">&#39;OIII5007&#39;</span><span class="p">:</span> <span class="mf">500.684</span><span class="p">,</span>
                          <span class="s1">&#39;Hbeta&#39;</span><span class="p">:</span> <span class="mf">486.133</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_functions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;sinc&#39;</span><span class="p">,</span> <span class="s1">&#39;sincgauss&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_clean</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>  <span class="c1"># Clean normalized spectrum that will be used for calculating the noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>  <span class="c1"># Redshifted axis</span>
        <span class="c1">#self.axis_unshifted = axis_unshifted  # Non-redshifted axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavenumbers_syn</span> <span class="o">=</span> <span class="n">wavenumbers_syn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">=</span> <span class="n">model_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>  <span class="c1"># Number of  lines to fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_filter</span> <span class="o">=</span> <span class="n">trans_filter</span>
        <span class="k">if</span> <span class="n">trans_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_transmission</span><span class="p">()</span>  <span class="c1"># Apply transmission filter if one is provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">=</span> <span class="nb">filter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_interpolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_normalized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">)</span>  <span class="c1"># Normalized spectrum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_interp_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cos_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correction_factor</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Initialize Correction factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis_step</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Initialize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta_x</span> <span class="o">=</span> <span class="n">delta_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_steps</span> <span class="o">=</span> <span class="n">n_steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_correction</span><span class="p">()</span>
        <span class="c1"># Update axis with correction factor</span>
        <span class="c1">#self.axis = self.axis*self.correction_factor</span>
        <span class="c1"># Calculate noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="mf">1e-2</span>  <span class="c1"># Initialize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_noise</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_rel</span> <span class="o">=</span> <span class="n">sigma_rel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vel_rel</span> <span class="o">=</span> <span class="n">vel_rel</span>
        <span class="c1"># ADD ML_MODEL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ML_model</span> <span class="o">=</span> <span class="n">ML_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bayes_bool</span> <span class="o">=</span> <span class="n">bayes_bool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uncertainty_bool</span> <span class="o">=</span> <span class="n">uncertainty_bool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Sacling factor used to normalize spectrum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sinc_width</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Width of the sinc function -- Initialize to zero</span>
        <span class="c1">#if sincgauss_args is None:</span>
        <span class="c1">#    sincgauss_args = [11.96, 2.1, 892]  # Randomly initialize these values  # TODO: Look niito best values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_sinc_width</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">cos_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_steps</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vel_ml</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># ML Estimate of the velocity [km/s]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broad_ml</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># ML Estimate of the velocity dispersion [km/s]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Solution to the fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 1-sigma errors on fit parameters</span>
        <span class="c1"># Set bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_max</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#  14700;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="mf">1e8</span> <span class="c1">#  15600</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_min</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_max</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="c1"># Check that lines inputted by user are in line_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_lines</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_fitting_model</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_lengths</span><span class="p">()</span>







<div class="viewcode-block" id="Fit.apply_transmission"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.apply_transmission">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transmission</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply transmission curve on the spectra according to un-redshifted axis.</span>
<span class="sd">        This is done before we interpolate onto the wavenumbers_syn so that the axis</span>
<span class="sd">        align properly. Note -- the values of the x-axis are not important for this</span>
<span class="sd">        division since we have already interpolated the transition filter vector</span>
<span class="sd">        over the UNSHIFTED spectral axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_filter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_filter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">))]</span></div>


<div class="viewcode-block" id="Fit.calculate_correction"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.calculate_correction">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate correction factor based of interferometric angle. This is used to correct the broadening</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correction_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">cos_theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correction_factor</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_steps</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e7</span></div>



<div class="viewcode-block" id="Fit.calc_sinc_width"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.calc_sinc_width">[docs]</a>    <span class="k">def</span> <span class="nf">calc_sinc_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sincgauss_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate sinc width of the sincgauss function</span>
<span class="sd">        Args:</span>
<span class="sd">            sincgauss_args: Additional arguments required for sincgauss function in a list:</span>
<span class="sd">            [Cosine of the Interfermeter Angle as calculated in Luci.get_interferometer_angle(), step_delta, n_steps]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">MPD</span> <span class="o">=</span> <span class="n">sincgauss_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sincgauss_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sincgauss_args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sinc_width</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">MPD</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fit.calculate_noise"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.calculate_noise">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate noise level in spectrum. We assume the noise is homogenous across the</span>
<span class="sd">        spectrum. We estimate it by taking a region outside of the filter and calculating</span>
<span class="sd">        the standard deviation in that region. We use the normalized spectrum since that</span>
<span class="sd">        is what is passed to the fit function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine filter</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">==</span> <span class="s1">&#39;SN3&#39;</span><span class="p">:</span>
            <span class="n">bound_lower</span> <span class="o">=</span> <span class="mi">14250</span><span class="c1">#16000</span>
            <span class="n">bound_upper</span> <span class="o">=</span> <span class="mi">14400</span><span class="c1">#16400</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">==</span> <span class="s1">&#39;SN2&#39;</span><span class="p">:</span>
            <span class="n">bound_lower</span> <span class="o">=</span> <span class="mi">18600</span>
            <span class="n">bound_upper</span> <span class="o">=</span> <span class="mi">19000</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span> <span class="o">==</span> <span class="s1">&#39;SN1&#39;</span><span class="p">:</span>
            <span class="n">bound_lower</span> <span class="o">=</span> <span class="mi">25300</span>
            <span class="n">bound_upper</span> <span class="o">=</span> <span class="mi">25700</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The filter of your datacube is not supported by LUCI. We only support SN1, SN2, and SN3 at the moment.&#39;</span><span class="p">)</span>
        <span class="c1"># Calculate standard deviation</span>
        <span class="c1">#print(np.min(self.axis), np.max(self.axis))</span>
        <span class="c1">#print(bound_upper, bound_lower)</span>
        <span class="n">min_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span><span class="o">-</span><span class="n">bound_lower</span><span class="p">))</span>
        <span class="c1">#print(min_)</span>
        <span class="n">max_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span><span class="o">-</span><span class="n">bound_upper</span><span class="p">))</span>
        <span class="c1">#print(max_)</span>
        <span class="n">spec_noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_clean</span><span class="p">[</span><span class="n">min_</span><span class="p">:</span><span class="n">max_</span><span class="p">]</span>
        <span class="c1">#print(spec_noise)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">spec_noise</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fit.estimate_priors_ML"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.estimate_priors_ML">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_priors_ML</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO: Test</span>
<span class="sd">        Apply machine learning algorithm on spectrum in order to estimate the velocity.</span>
<span class="sd">        The spectrum fed into this method must be interpolated already onto the</span>
<span class="sd">        reference spectrum axis AND normalized as described in Rhea et al. 2020a.</span>
<span class="sd">        Args:</span>
<span class="sd">            ml_dir: Relative path to the trained ML Predictor (e.g. R5000-PREDICITOR-I)</span>
<span class="sd">        Return:</span>
<span class="sd">            Updates self.vel_ml</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_interp_norm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_interp_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ML_model</span><span class="p">(</span><span class="n">Spectrum</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vel_ml</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">predictions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broad_ml</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">predictions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Multiply value by FWHM of a gaussian</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Fit.interpolate_spectrum"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.interpolate_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate Spectrum given the wavelength axis of reference spectrum.</span>
<span class="sd">        Then normalize the spectrum so that the max value equals 1</span>

<span class="sd">        Return:</span>
<span class="sd">            Populates self.spectrum_interpolated, self.spectrum_scale, and self.spectrum_interp_norm.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;slinear&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_interpolated</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavenumbers_syn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_interpolated</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_interp_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_interpolated</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
        <span class="c1"># self.spectrum_interpolated = np.real(sky_corr)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Fit.line_vals_estimate"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.line_vals_estimate">[docs]</a>    <span class="k">def</span> <span class="nf">line_vals_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO: Test</span>

<span class="sd">        Function to estimate the position and amplitude of a given line.</span>

<span class="sd">        Args:</span>
<span class="sd">            spec: Spectrum flux values</span>
<span class="sd">            line_name: Name of model. Available options are &#39;Halpha&#39;, &#39;NII6548&#39;, &#39;NII6543&#39;, &#39;SII6716&#39;, &#39;SII6731&#39;</span>

<span class="sd">        Return:</span>
<span class="sd">            Estimated line amplitude in units of cm-1 (line_amp_est) and estimate line position in units of cm-1 (line_pos_est)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">line_theo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_dict</span><span class="p">[</span><span class="n">line_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ML_model</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">max_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_normalized</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vel_ml</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">3e5</span> <span class="o">*</span> <span class="p">((</span><span class="mf">1e7</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">[</span><span class="n">max_flux</span><span class="p">]</span> <span class="o">-</span> <span class="n">line_theo</span><span class="p">)</span> <span class="o">/</span> <span class="n">line_theo</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">broad_ml</span> <span class="o">=</span> <span class="mf">10.0</span>  <span class="c1"># Best for now</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># vel_ml and broad_ml already set using ML algorithm</span>
        <span class="n">line_pos_est</span> <span class="o">=</span> <span class="mf">1e7</span> <span class="o">/</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">vel_ml</span> <span class="o">/</span> <span class="mf">3e5</span><span class="p">)</span> <span class="o">*</span> <span class="n">line_theo</span> <span class="o">+</span> <span class="n">line_theo</span><span class="p">)</span>  <span class="c1"># Estimate of position of line in cm-1</span>
        <span class="n">line_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span> <span class="o">-</span> <span class="n">line_pos_est</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">line_amp_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_normalized</span><span class="p">[</span><span class="n">line_ind</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_normalized</span><span class="p">[</span><span class="n">line_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_normalized</span><span class="p">[</span><span class="n">line_ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_normalized</span><span class="p">[</span><span class="n">line_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_normalized</span><span class="p">[</span><span class="n">line_ind</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">line_amp_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_normalized</span><span class="p">[</span><span class="n">line_ind</span><span class="p">]</span>
        <span class="n">line_broad_est</span> <span class="o">=</span> <span class="p">(</span><span class="n">line_pos_est</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">broad_ml</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">3e5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">line_amp_est</span><span class="p">,</span> <span class="n">line_pos_est</span><span class="p">,</span> <span class="n">line_broad_est</span></div>

<div class="viewcode-block" id="Fit.gaussian_model"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.gaussian_model">[docs]</a>    <span class="k">def</span> <span class="nf">gaussian_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to initiate the correct number of models to fit</span>

<span class="sd">        Args:</span>
<span class="sd">            channel: Wavelength Axis in cm-1</span>
<span class="sd">            theta: List of parameters for all the models in the following order</span>
<span class="sd">                            [amplitude, line location, sigma]</span>

<span class="sd">        Return:</span>
<span class="sd">            Value of function given input parameters (theta)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">model_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_num</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">model_num</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:(</span><span class="n">model_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">f1</span> <span class="o">+=</span> <span class="n">Gaussian</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">func</span>
        <span class="k">return</span> <span class="n">f1</span></div>


<div class="viewcode-block" id="Fit.sinc_model"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.sinc_model">[docs]</a>    <span class="k">def</span> <span class="nf">sinc_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to initiate the correct number of models to fit</span>

<span class="sd">        Args:</span>
<span class="sd">            channel: Wavelength Axis in cm-1</span>
<span class="sd">            theta: List of parameters for all the models in the following order</span>
<span class="sd">                            [amplitude, line location, sigma]</span>

<span class="sd">        Return:</span>
<span class="sd">            Value of function given input parameters (theta)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">model_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_num</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">model_num</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:(</span><span class="n">model_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">f1</span> <span class="o">+=</span> <span class="n">Sinc</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">func</span>
        <span class="k">return</span> <span class="n">f1</span></div>


<div class="viewcode-block" id="Fit.sincgauss_model"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.sincgauss_model">[docs]</a>    <span class="k">def</span> <span class="nf">sincgauss_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to initiate the correct number of models to fit</span>

<span class="sd">        Args:</span>
<span class="sd">            channel: Wavelength Axis in cm-1</span>
<span class="sd">            theta: List of parameters for all the models in the following order</span>
<span class="sd">                            [amplitude, line location, sigma]</span>

<span class="sd">        Return:</span>
<span class="sd">            Value of function given input parameters (theta)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">model_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_num</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">model_num</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:(</span><span class="n">model_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">f1</span> <span class="o">+=</span> <span class="n">SincGauss</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sinc_width</span><span class="p">)</span><span class="o">.</span><span class="n">func</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fit.log_likelihood"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.log_likelihood">[docs]</a>    <span class="k">def</span> <span class="nf">log_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate log likelihood function evaluated given parameters on spectral axis</span>

<span class="sd">        Args:</span>
<span class="sd">            theta - List of parameters for all the models in the following order</span>
<span class="sd">                            [amplitude, line location, sigma, continuum constant]</span>
<span class="sd">                    The continuum constant is always the last argument regardless of the number of lines being modeled</span>
<span class="sd">            yerr: Error on Spectrum&#39;s flux values (default 1e-2)</span>
<span class="sd">        Return:</span>
<span class="sd">            Value of log likelihood</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;sinc&#39;</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sinc_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;sincgauss&#39;</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sincgauss_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="c1"># Add constant contimuum to model</span>
        <span class="n">model</span> <span class="o">+=</span> <span class="n">theta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sigma2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_normalized</span> <span class="o">-</span> <span class="n">model</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">sigma2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sigma2</span><span class="p">))</span></div>

<div class="viewcode-block" id="Fit.fun_der"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciFit.Fit.fun_der">[docs]</a>    <span class="k">def</span> <span class="nf">fun_der</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">yerr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Jacobian</span><span class="p">(</span><span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">yerr</span><span class="p">))(</span><span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span></div>


<div class="viewcode-block" id="Fit.sigma_constraints"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.sigma_constraints">[docs]</a>    <span class="k">def</span> <span class="nf">sigma_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up constraints for sigma values before fitting line</span>
<span class="sd">        Return:</span>
<span class="sd">            Dictionary describing constraints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma_dict_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unique_rels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_rel</span><span class="p">)</span>  <span class="c1"># List of unique groups</span>
        <span class="k">for</span> <span class="n">unique_</span> <span class="ow">in</span> <span class="n">unique_rels</span><span class="p">:</span>  <span class="c1"># Step through each unique group</span>
            <span class="n">inds_unique</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_rel</span><span class="p">)</span> <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">unique_</span><span class="p">]</span>  <span class="c1"># Obtain line indices in group</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds_unique</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># If there is more than one element in the group</span>
                <span class="n">ind_0</span> <span class="o">=</span> <span class="n">inds_unique</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Get first element</span>
                <span class="k">for</span> <span class="n">ind_unique</span> <span class="ow">in</span> <span class="n">inds_unique</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>  <span class="c1"># Step through group elements except for the first one</span>
                    <span class="n">sigma_dict_list</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind_0</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind_unique</span><span class="o">+</span><span class="mi">2</span><span class="p">]})</span>
        <span class="k">return</span> <span class="n">sigma_dict_list</span></div>

<div class="viewcode-block" id="Fit.vel_constraints"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.vel_constraints">[docs]</a>    <span class="k">def</span> <span class="nf">vel_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up constraints for velocity values before fitting line</span>
<span class="sd">        Return:</span>
<span class="sd">            Dictionary describing constraints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vel_dict_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unique_rels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vel_rel</span><span class="p">)</span>  <span class="c1"># List of unique groups</span>
        <span class="k">for</span> <span class="n">unique_</span> <span class="ow">in</span> <span class="n">unique_rels</span><span class="p">:</span>  <span class="c1"># Step through each unique group</span>
            <span class="n">inds_unique</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vel_rel</span><span class="p">)</span> <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">unique_</span><span class="p">]</span>  <span class="c1"># Obtain line indices in group</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds_unique</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># If there is more than one element in the group</span>
                <span class="n">ind_0</span> <span class="o">=</span> <span class="n">inds_unique</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Get first element</span>
                <span class="k">for</span> <span class="n">ind_unique</span> <span class="ow">in</span> <span class="n">inds_unique</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>  <span class="c1"># Step through group elements except for the first one</span>
                    <span class="n">expr_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">3e5</span> <span class="o">*</span> <span class="p">((</span><span class="mf">1e7</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind_unique</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind_unique</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1e7</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind_unique</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span> <span class="o">-</span> <span class="mf">3e5</span> <span class="o">*</span> <span class="p">(</span>
                                     <span class="p">(</span><span class="mf">1e7</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind_0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind_0</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1e7</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind_0</span><span class="o">+</span><span class="mi">1</span><span class="p">]))}</span>
        <span class="k">return</span> <span class="n">vel_dict_list</span></div>


<div class="viewcode-block" id="Fit.calculate_params"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.calculate_params">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the amplitude, position, and sigma of the line. These values are</span>
<span class="sd">        calculated using the scipy.optimize.minimize function. This is called</span>
<span class="sd">        on the log likelood previously described. The minimization algorithm uses</span>
<span class="sd">        the SLSQP optimization implementation. We have applied standard bounds in order</span>
<span class="sd">        to speed up the fitting. We also apply the fit on the normalized spectrum.</span>
<span class="sd">        We then correct the flux by un-normalizing the spectrum.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nll</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">bounds_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mod</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_num</span><span class="p">):</span>
            <span class="c1">#val = 3 * mod + 1</span>
            <span class="n">amp_est</span><span class="p">,</span> <span class="n">vel_est</span><span class="p">,</span> <span class="n">sigma_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_vals_estimate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">mod</span><span class="p">])</span>
            <span class="n">initial</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">mod</span><span class="p">]</span> <span class="o">=</span> <span class="n">amp_est</span>
            <span class="n">initial</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">mod</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vel_est</span>
            <span class="n">initial</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">mod</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_est</span>
            <span class="n">bounds_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">A_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_max</span><span class="p">))</span>
            <span class="n">bounds_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">))</span>
            <span class="n">bounds_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_max</span><span class="p">))</span>
        <span class="n">initial</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># Add continuum constant and intialize it at 0.1 for the normalized spectrum</span>
        <span class="n">bounds_l</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bounds_</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Continuum Constraint</span>
        <span class="n">bounds_u</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bounds_</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Continuum Constraint</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">Bounds</span><span class="p">(</span><span class="n">bounds_l</span><span class="p">,</span> <span class="n">bounds_u</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inital_values</span> <span class="o">=</span> <span class="n">initial</span>
        <span class="n">sigma_cons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_constraints</span><span class="p">()</span>
        <span class="n">vel_cons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vel_constraints</span><span class="p">()</span>
        <span class="n">cons</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma_cons</span> <span class="o">+</span> <span class="n">vel_cons</span><span class="p">)</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">nll</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="c1">#method=&#39;SLSQP&#39;,# jac=self.fun_der(),</span>
                        <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">},</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
                        <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">)</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">soln</span><span class="o">.</span><span class="n">x</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertainty_bool</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Calculate uncertainties using the negative inverse hessian  as the covariance matrix</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">hessian</span> <span class="o">=</span> <span class="n">Hessian</span><span class="p">(</span><span class="n">nll</span><span class="p">)</span>
                <span class="n">hessian_calc</span> <span class="o">=</span> <span class="n">hessian</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
                <span class="n">covariance_mat</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">hessian_calc</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">covariance_mat</span><span class="p">)))</span>
            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        <span class="c1"># We now must unscale the amplitude</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_num</span><span class="p">):</span>
            <span class="n">parameters</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
        <span class="c1"># Scale continuum</span>
        <span class="n">parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;sinc&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sinc_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;sincgauss&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sincgauss_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Fit.calculate_vel"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.calculate_vel">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate velocity</span>

<span class="sd">        Args:</span>
<span class="sd">            ind: Index of line in lines</span>
<span class="sd">        Return:</span>
<span class="sd">            Velocity of the Halpha line in units of km/s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">line_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">l_calc</span> <span class="o">=</span> <span class="mf">1e7</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">l_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">l_calc</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_dict</span><span class="p">[</span><span class="n">line_name</span><span class="p">])</span> <span class="o">/</span> <span class="n">l_calc</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mf">3e5</span> <span class="o">*</span> <span class="n">l_shift</span>
        <span class="k">return</span> <span class="n">v</span></div>


<div class="viewcode-block" id="Fit.calculate_vel_err"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.calculate_vel_err">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_vel_err</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate velocity error</span>
<span class="sd">        TODO: Test</span>

<span class="sd">        Args:</span>
<span class="sd">            ind: Index of line in lines</span>
<span class="sd">        Return:</span>
<span class="sd">            Velocity of the Halpha line in units of km/s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">line_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">l_calc1</span> <span class="o">=</span> <span class="mf">1e7</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">l_calc2</span> <span class="o">=</span> <span class="mf">1e7</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">l_shift1</span> <span class="o">=</span> <span class="p">(</span><span class="n">l_calc1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_dict</span><span class="p">[</span><span class="n">line_name</span><span class="p">])</span> <span class="o">/</span> <span class="n">l_calc1</span>
        <span class="n">l_shift2</span> <span class="o">=</span> <span class="p">(</span><span class="n">l_calc2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_dict</span><span class="p">[</span><span class="n">line_name</span><span class="p">])</span> <span class="o">/</span> <span class="n">l_calc2</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="mf">3e5</span> <span class="o">*</span> <span class="n">l_shift1</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="mf">3e5</span> <span class="o">*</span> <span class="n">l_shift2</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v1</span> <span class="o">-</span> <span class="n">v2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fit.calculate_broad"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.calculate_broad">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_broad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate velocity dispersion</span>
<span class="sd">        TODO: Test</span>

<span class="sd">        Args:</span>
<span class="sd">            ind: Index of line in lines</span>
<span class="sd">        Return:</span>
<span class="sd">            Velocity Dispersion of the Halpha line in units of km/s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">broad</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3e5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">broad</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fit.calculate_broad_err"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.calculate_broad_err">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_broad_err</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate velocity dispersion error</span>

<span class="sd">        Args:</span>
<span class="sd">            ind: Index of line in lines</span>
<span class="sd">        Return:</span>
<span class="sd">            Velocity Dispersion of the Halpha line in units of km/s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">broad1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3e5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">broad2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3e5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">2</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">broad1</span><span class="o">-</span><span class="n">broad2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fit.calculate_flux"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.calculate_flux">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_amp</span><span class="p">,</span> <span class="n">line_sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate flux value given fit of line</span>
<span class="sd">        TODO: Test</span>

<span class="sd">        Args:</span>
<span class="sd">            line_amp: Amplitude of the line (un-normalized)</span>
<span class="sd">            line_sigma: Sigma of the line fit</span>
<span class="sd">        Return:</span>
<span class="sd">            Flux of the provided line in units of erg/s/cm-2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Initialize</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">line_amp</span> <span class="o">*</span> <span class="n">line_sigma</span>
            <span class="c1">#print(line_sigma)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;sinc&#39;</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">line_amp</span> <span class="o">*</span> <span class="n">line_sigma</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;sincgauss&#39;</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">line_amp</span> <span class="o">*</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">line_sigma</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">erf</span><span class="p">((</span><span class="n">line_sigma</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sinc_width</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR: INCORRECT FIT FUNCTION&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flux</span></div>


<div class="viewcode-block" id="Fit.calc_chisquare"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.calc_chisquare">[docs]</a>    <span class="k">def</span> <span class="nf">calc_chisquare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_vector</span><span class="p">,</span> <span class="n">init_spectrum</span><span class="p">,</span> <span class="n">init_errors</span><span class="p">,</span> <span class="n">n_dof</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate reduced chi 2</span>

<span class="sd">        Args:</span>
<span class="sd">            fit_vector: Spectrum obtained from fit</span>
<span class="sd">            init_spectrum: Observed spectrum</span>
<span class="sd">            init_errors: Errors on observed spectrum</span>
<span class="sd">            n_dof: Number of degrees of freedom</span>

<span class="sd">        Return:</span>
<span class="sd">            chi2: Chi squared value</span>
<span class="sd">            chi2dof: Reduced chi squared value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute the mean and the chi^2/dof</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">fit_vector</span> <span class="o">-</span> <span class="n">init_spectrum</span><span class="p">)</span><span class="c1"># / init_errors</span>
        <span class="n">chi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">chi2dof</span> <span class="o">=</span> <span class="n">chi2</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_dof</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chi2</span><span class="p">,</span> <span class="n">chi2dof</span></div>


<div class="viewcode-block" id="Fit.fit"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Primary function call for a spectrum. This will estimate the velocity using</span>
<span class="sd">        our machine learning algorithm described in Rhea et al. 2020a. Then we will</span>
<span class="sd">        fit our lines using scipy.optimize.minimize.</span>

<span class="sd">        Return:</span>
<span class="sd">            dictionary of parameters returned by the fit. The dictionary has the following form:</span>
<span class="sd">            {&quot;fit_vector&quot;: Fitted spectrum, &quot;velocity&quot;: Velocity of the line in km/s (float),</span>
<span class="sd">            &quot;broadening&quot;: Velocity Dispersion of the line in km/s (float)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ML_model</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Interpolate Spectrum</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_spectrum</span><span class="p">()</span>
            <span class="c1"># Estimate the priors using machine learning algorithm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">estimate_priors_ML</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="c1"># Apply Fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_params</span><span class="p">()</span>
        <span class="c1"># Check if Bayesian approach is required</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayes_bool</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_Bayes</span><span class="p">()</span>
        <span class="c1"># Calculate fit statistic</span>
        <span class="n">chi_sqr</span><span class="p">,</span> <span class="n">red_chi_sqr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_chisquare</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">line_num</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Collect Amplitudes</span>
        <span class="n">ampls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fluxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sigmas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vels_errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sigmas_errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line_ct</span><span class="p">,</span> <span class="n">line_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">):</span>  <span class="c1"># Step through each line</span>
            <span class="n">ampls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="n">line_ct</span> <span class="o">*</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># Calculate flux</span>
            <span class="n">fluxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calculate_flux</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="n">line_ct</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="n">line_ct</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]))</span>
            <span class="n">vels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calculate_vel</span><span class="p">(</span><span class="n">line_ct</span><span class="p">))</span>
            <span class="n">sigmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calculate_broad</span><span class="p">(</span><span class="n">line_ct</span><span class="p">))</span>
            <span class="n">vels_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calculate_vel_err</span><span class="p">(</span><span class="n">line_ct</span><span class="p">))</span>
            <span class="n">sigmas_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calculate_broad_err</span><span class="p">(</span><span class="n">line_ct</span><span class="p">))</span>
        <span class="c1"># Collect parameters to return in a dictionary</span>
        <span class="n">fit_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fit_sol&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">,</span> <span class="s1">&#39;fit_uncertainties&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span><span class="p">,</span>
                    <span class="s1">&#39;fit_vector&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_vector</span><span class="p">,</span>
                    <span class="s1">&#39;velocity&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_vel</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;broadening&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_broad</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="s1">&#39;velocity_err&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_vel_err</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="s1">&#39;broadening_err&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_broad_err</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="s1">&#39;amplitudes&#39;</span><span class="p">:</span> <span class="n">ampls</span><span class="p">,</span> <span class="s1">&#39;fluxes&#39;</span><span class="p">:</span> <span class="n">fluxes</span><span class="p">,</span> <span class="s1">&#39;chi2&#39;</span><span class="p">:</span> <span class="n">chi_sqr</span><span class="p">,</span> <span class="s1">&#39;velocities&#39;</span><span class="p">:</span> <span class="n">vels</span><span class="p">,</span>
                    <span class="s1">&#39;sigmas&#39;</span><span class="p">:</span> <span class="n">sigmas</span><span class="p">,</span> <span class="s1">&#39;vels_errors&#39;</span><span class="p">:</span> <span class="n">vels_errors</span><span class="p">,</span> <span class="s1">&#39;sigmas_errors&#39;</span><span class="p">:</span> <span class="n">sigmas_errors</span><span class="p">,</span>
                    <span class="s1">&#39;axis_step&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_step</span><span class="p">,</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">correction_factor</span><span class="p">,</span>
                    <span class="s1">&#39;continuum&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">fit_dict</span></div>

<div class="viewcode-block" id="Fit.fit_Bayes"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.fit_Bayes">[docs]</a>    <span class="k">def</span> <span class="nf">fit_Bayes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply Bayesian MCMC run to constrain the parameters after solving</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Unscale the amplitude</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_num</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
        <span class="n">n_dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_num</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">n_walkers</span> <span class="o">=</span> <span class="n">n_dim</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="n">init_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_walkers</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>
        <span class="c1">#print(self.noise)</span>
        <span class="n">sampler</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">EnsembleSampler</span><span class="p">(</span><span class="n">n_walkers</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_probability</span><span class="p">,</span>
                                        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_normalized</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">))</span>
        <span class="n">sampler</span><span class="o">.</span><span class="n">run_mcmc</span><span class="p">(</span><span class="n">init_</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">flat_samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_chain</span><span class="p">(</span><span class="n">discard</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#parameters = []</span>
        <span class="n">parameters_med</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parameters_std</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dim</span><span class="p">):</span>
            <span class="c1">#mcmc = np.percentile(flat_samples[:, i], [16, 50, 84])</span>
            <span class="c1">#parameters.append(mcmc[1])</span>
            <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flat_samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">flat_samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">parameters_med</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">median</span><span class="p">)</span>
            <span class="n">parameters_std</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span> <span class="o">=</span> <span class="n">parameters_med</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span> <span class="o">=</span> <span class="n">parameters_std</span>
        <span class="c1"># Now rescale the amplitude</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_num</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
        <span class="c1"># Scale continuum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uncertainties</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_scale</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;sinc&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sinc_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;sincgauss&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sincgauss_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="Fit.log_likelihood_bayes"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.log_likelihood_bayes">[docs]</a>    <span class="k">def</span> <span class="nf">log_likelihood_bayes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">model__</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># model = self.gaussian_model(x, theta, model)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="n">sigma2</span> <span class="o">=</span> <span class="n">yerr</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">model</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">sigma2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sigma2</span><span class="p">))</span></div>

<div class="viewcode-block" id="Fit.log_prior"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciFit.Fit.log_prior">[docs]</a>    <span class="k">def</span> <span class="nf">log_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="n">A_min</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 1e-19</span>
        <span class="n">A_max</span> <span class="o">=</span> <span class="mf">1.1</span>  <span class="c1"># 1e-15</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">#14700</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="mf">1e7</span><span class="c1">#15400</span>
        <span class="n">sigma_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sigma_max</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="k">for</span> <span class="n">model_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="p">)):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">model_num</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:(</span><span class="n">model_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">within_bounds</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Boolean to determine if parameters are within bounds</span>
        <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ct</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Amplitude parameter</span>
                <span class="k">if</span> <span class="n">param</span> <span class="o">&gt;</span> <span class="n">A_min</span> <span class="ow">and</span> <span class="n">param</span> <span class="o">&lt;</span> <span class="n">A_max</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">within_bounds</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Value not in bounds</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">ct</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># velocity parameter</span>
                <span class="k">if</span> <span class="n">param</span> <span class="o">&gt;</span> <span class="n">x_min</span> <span class="ow">and</span> <span class="n">param</span> <span class="o">&lt;</span> <span class="n">x_max</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">within_bounds</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Value not in bounds</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">ct</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># sigma parameter</span>
                <span class="k">if</span> <span class="n">param</span> <span class="o">&gt;</span> <span class="n">sigma_min</span> <span class="ow">and</span> <span class="n">param</span> <span class="o">&lt;</span> <span class="n">sigma_max</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">within_bounds</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Value not in bounds</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">within_bounds</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>
        <span class="c1"># A_,x_,sigma_ = theta</span>
        <span class="c1"># if A_min &lt; A_ &lt; A_max and x_min &lt; x_ &lt; x_max and sigma_min &lt; sigma_ &lt; sigma_max:</span>
        <span class="c1">#    return 0.0#np.log(1/((t_max-t_min)*(rp_max-rp_min)*(b_max-b_min)))</span>
        <span class="c1"># return -np.inf</span>

<div class="viewcode-block" id="Fit.log_probability"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciFit.Fit.log_probability">[docs]</a>    <span class="k">def</span> <span class="nf">log_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="n">lp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_prior</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">lp</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="n">lp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood_bayes</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fit.check_lines"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.check_lines">[docs]</a>    <span class="k">def</span> <span class="nf">check_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks to see that the lines provided are in the available options</span>
<span class="sd">        Return:</span>
<span class="sd">        Nothing if the user provides appropriate lines</span>
<span class="sd">        Else it will throw an error</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_dict</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Please submit a line name in the available list: </span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Fit.check_fitting_model"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.check_fitting_model">[docs]</a>    <span class="k">def</span> <span class="nf">check_fitting_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks to see that the model provided is in the available options</span>
<span class="sd">        Return:</span>
<span class="sd">        Nothing if the user provides an appropriate fitting model</span>
<span class="sd">        Else it will throw an error</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_functions</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_type</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s1">&#39;Please submit a fitting function name in the available list: </span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_functions</span><span class="p">))</span></div>


<div class="viewcode-block" id="Fit.check_lengths"><a class="viewcode-back" href="../../source/fits.html#LUCI.LuciFit.Fit.check_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">check_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks to see that the length of the sigma_rel and vel_rel arguments are correct</span>
<span class="sd">        Return:</span>
<span class="sd">        Nothing if the user provides appropriate length</span>
<span class="sd">        Else it will throw an error</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vel_rel</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The argument vel_rel has </span><span class="si">%i</span><span class="s2"> arguments, but it should have </span><span class="si">%i</span><span class="s2"> arguments&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vel_rel</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_rel</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The argument sigma_rel has </span><span class="si">%i</span><span class="s2"> arguments, but it should have </span><span class="si">%i</span><span class="s2"> arguments&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_rel</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">LUCI-package</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/modules.html">Module Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Carter Rhea.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>