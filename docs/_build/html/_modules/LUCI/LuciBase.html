
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LUCI.LuciBase &#8212; LUCI-package  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for LUCI.LuciBase</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">astropy.wcs</span> <span class="kn">import</span> <span class="n">WCS</span>
<span class="kn">from</span> <span class="nn">astropy.wcs.utils</span> <span class="kn">import</span> <span class="n">pixel_to_skycoord</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">keras</span>
<span class="kn">import</span> <span class="nn">pyregion</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">LUCI.LuciFit</span> <span class="kn">import</span> <span class="n">Fit</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">astropy.nddata</span> <span class="kn">import</span> <span class="n">Cutout2D</span>
<span class="kn">from</span> <span class="nn">astroquery.astrometry_net</span> <span class="kn">import</span> <span class="n">AstrometryNet</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span>


<div class="viewcode-block" id="Luci"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci">[docs]</a><span class="k">class</span> <span class="nc">Luci</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the primary class for the general purpose line fitting code LUCI. This contains</span>
<span class="sd">    all io/administrative functionality. The fitting functionality can be found in the</span>
<span class="sd">    Fit class (Lucifit.py).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Luci_path</span><span class="p">,</span> <span class="n">cube_path</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">object_name</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">ML_bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span><span class="c1">#ref_spec=None, model_ML_name=None):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize our Luci class -- this acts similar to the SpectralCube class</span>
<span class="sd">        of astropy or spectral-cube.</span>

<span class="sd">        Args:</span>
<span class="sd">            Luci_path: Path to Luci</span>
<span class="sd">            cube_path: Full path to hdf5 cube with the hdf5 extension (e.x. &#39;/user/home/M87.hdf5&#39;)</span>
<span class="sd">            output_dir: Full path to output directory</span>
<span class="sd">            object_name: Name of the object to fit. This is used for naming purposes. (e.x. &#39;M87&#39;)</span>
<span class="sd">            redshift: Redshift to the object. (e.x. 0.00428)</span>
<span class="sd">            resolution: Resolution requested of machine learning algorithm reference spectrum</span>
<span class="sd">            ML_bool: Boolean for applying machine learning; default=True</span>
<span class="sd">            ref_spec: Name of reference spectrum for machine learning algo (e.x. &#39;Reference-Spectrum-R5000&#39;)</span>
<span class="sd">            model_ML_name: Name of pretrained machine learning model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Luci_path</span> <span class="o">=</span> <span class="n">Luci_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_path</span> <span class="o">=</span> <span class="n">cube_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/Luci&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object_name</span> <span class="o">=</span> <span class="n">object_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="n">redshift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad_nb</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Number of quadrants in Hdf5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># X dimension of cube</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimy</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Y dimension of cube</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimz</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Z dimension of cube</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Complete data cube</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_binned</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Binned data cube</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deep_image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis_unshifted</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Spectrum axis without redshift change</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavenumbers_syn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interferometer_theta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmission_interpolated</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_in_cube</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis_func</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ML_bool</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;SN1&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ref_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Luci_path</span><span class="o">+</span><span class="s1">&#39;ML/Reference-Spectrum-R</span><span class="si">%i</span><span class="s1">-SN1.fits&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model_ML</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Luci_path</span><span class="o">+</span><span class="s1">&#39;ML/R</span><span class="si">%i</span><span class="s1">-PREDICTOR-I-SN1&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">resolution</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;SN2&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ref_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Luci_path</span><span class="o">+</span><span class="s1">&#39;ML/Reference-Spectrum-R</span><span class="si">%i</span><span class="s1">-SN2.fits&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model_ML</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Luci_path</span><span class="o">+</span><span class="s1">&#39;ML/R</span><span class="si">%i</span><span class="s1">-PREDICTOR-I-SN2&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">resolution</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;SN3&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ref_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Luci_path</span><span class="o">+</span><span class="s1">&#39;ML/Reference-Spectrum-R</span><span class="si">%i</span><span class="s1">.fits&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model_ML</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Luci_path</span><span class="o">+</span><span class="s1">&#39;ML/R</span><span class="si">%i</span><span class="s1">-PREDICTOR-I&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">resolution</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;LUCI does not support machine learning parameter estimates for the filter you entered. Please set ML_bool=False.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_in_reference_spectrum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_ML</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_in_transmission</span><span class="p">()</span>


<div class="viewcode-block" id="Luci.get_quadrant_dims"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.get_quadrant_dims">[docs]</a>    <span class="k">def</span> <span class="nf">get_quadrant_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quad_number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the x and y limits of a given quadrant in the HDF5 file. The</span>
<span class="sd">        data cube is saved in 9 individual arrays in the original HDF5 cube. This</span>
<span class="sd">        function gets the bouunds for each quadrant.</span>

<span class="sd">        Args:</span>
<span class="sd">            quad_number: Quadrant Number</span>
<span class="sd">        Return:</span>
<span class="sd">            x_min, x_max, y_min, y_max: Spatial bounds of quadrant</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">div_nb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_nb</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">quad_number</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">quad_number</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">quad_nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">StandardError</span><span class="p">(</span><span class="s2">&quot;quad_number out of bounds [0,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_nb</span><span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;SOMETHING FAILED&quot;</span>

        <span class="n">index_x</span> <span class="o">=</span> <span class="n">quad_number</span> <span class="o">%</span> <span class="n">div_nb</span>
        <span class="n">index_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">quad_number</span> <span class="o">-</span> <span class="n">index_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">div_nb</span>

        <span class="n">x_min</span> <span class="o">=</span> <span class="n">index_x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">/</span> <span class="n">div_nb</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index_x</span> <span class="o">!=</span> <span class="n">div_nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_x</span>  <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">/</span> <span class="n">div_nb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>

        <span class="n">y_min</span> <span class="o">=</span> <span class="n">index_y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimy</span> <span class="o">/</span> <span class="n">div_nb</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index_y</span> <span class="o">!=</span> <span class="n">div_nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">index_y</span>  <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimy</span> <span class="o">/</span> <span class="n">div_nb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimy</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_min</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_max</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_min</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_max</span><span class="p">)</span></div>


<div class="viewcode-block" id="Luci.get_interferometer_angles"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.get_interferometer_angles">[docs]</a>    <span class="k">def</span> <span class="nf">get_interferometer_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the interferometer angle 2d array for the entire cube. We use</span>
<span class="sd">        the following equation:</span>
<span class="sd">        cos(theta) = lambda_ref/lambda</span>
<span class="sd">        where lambda_ref is the reference laser wavelength and lambda is the measured calibration laser wavelength.</span>

<span class="sd">        Args:</span>
<span class="sd">            file: hdf5 File object containing HDF5 file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">calib_map</span> <span class="o">=</span> <span class="n">file</span><span class="p">[</span><span class="s1">&#39;calib_map&#39;</span><span class="p">][()]</span>
        <span class="n">calib_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;CALIBNM&#39;</span><span class="p">]</span>
        <span class="n">interferometer_cos_theta</span> <span class="o">=</span> <span class="n">calib_ref</span><span class="o">/</span><span class="n">calib_map</span><span class="c1">#.T[::-1,::-1]</span>
        <span class="c1"># We need to convert to degree so bear with me here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interferometer_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">interferometer_cos_theta</span><span class="p">))</span></div>


<div class="viewcode-block" id="Luci.update_header"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.update_header">[docs]</a>    <span class="k">def</span> <span class="nf">update_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a standard WCS header from the HDF5 header. To do this we clean up the</span>
<span class="sd">        header data (which is initially stored in individual arrays). We then create</span>
<span class="sd">        a new header dictionary with the old cleaned header info. Finally, we use</span>
<span class="sd">        astropy.wcs.WCS to create an updated WCS header for the 2 spatial dimensions.</span>
<span class="sd">        This is then saved to self.header while the header dictionary is saved</span>
<span class="sd">        as self.hdr_dict.</span>

<span class="sd">        Args:</span>
<span class="sd">            file: hdf5 File object containing HDF5 file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hdr_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">header_cols</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;b&quot;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">][()])]</span>
        <span class="n">header_vals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;b&quot;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">][()])]</span>
        <span class="n">header_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="s1">&#39;header&#39;</span><span class="p">][()])]</span>
        <span class="k">for</span> <span class="n">header_col</span><span class="p">,</span> <span class="n">header_val</span><span class="p">,</span> <span class="n">header_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">header_cols</span><span class="p">,</span><span class="n">header_vals</span><span class="p">,</span> <span class="n">header_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;bool&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">header_type</span><span class="p">):</span>
                <span class="n">hdr_dict</span><span class="p">[</span><span class="n">header_col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">header_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;float&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">header_type</span><span class="p">):</span>
                <span class="n">hdr_dict</span><span class="p">[</span><span class="n">header_col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">header_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;int&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">header_type</span><span class="p">):</span>
                <span class="n">hdr_dict</span><span class="p">[</span><span class="n">header_col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header_val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">hdr_dict</span><span class="p">[</span><span class="n">header_col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">header_val</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">hdr_dict</span><span class="p">[</span><span class="n">header_col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">header_val</span><span class="p">)</span>
        <span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;CTYPE3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;WAVE-SIP&#39;</span>
        <span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;CUNIT3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
        <span class="c1">#hdr_dict[&#39;NAXIS1&#39;] = 2064</span>
        <span class="c1">#hdr_dict[&#39;NAXIS2&#39;] = 2048</span>
        <span class="c1"># Make WCS</span>
        <span class="n">wcs_data</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">hdr_dict</span><span class="p">,</span> <span class="n">naxis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">wcs_data</span><span class="o">.</span><span class="n">to_header</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;WCSAXES&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;SIMPLE&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;SIMPLE&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#self.header.insert(&#39;NAXIS&#39;, (&#39;NAXIS1&#39;, 2064), after=True)</span>
        <span class="c1">#self.header.insert(&#39;NAXIS1&#39;, (&#39;NAXIS2&#39;, 2048), after=True)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span> <span class="o">=</span> <span class="n">hdr_dict</span></div>


<div class="viewcode-block" id="Luci.create_deep_image"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.create_deep_image">[docs]</a>    <span class="k">def</span> <span class="nf">create_deep_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create deep image fits file of the cube. This takes the cube and sums</span>
<span class="sd">        the spectral axis. Then the deep image is saved as a fits file with the following</span>
<span class="sd">        naming convention: output_dir+&#39;/&#39;+object_name+&#39;_deep.fits&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deep_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">output_name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="o">+</span><span class="s1">&#39;_deep.fits&#39;</span>
        <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deep_image</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Luci.read_in_cube"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.read_in_cube">[docs]</a>    <span class="k">def</span> <span class="nf">read_in_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to read the hdf5 data into a 3d numpy array (data cube). We also</span>
<span class="sd">        translate the header to standard wcs format by calling the update_header function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reading in data...&#39;</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span>  <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_path</span><span class="o">+</span><span class="s1">&#39;.hdf5&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>  <span class="c1"># Read in file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad_nb</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;quad_nb&#39;</span><span class="p">]</span>  <span class="c1"># Get the number of quadrants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dimx&#39;</span><span class="p">]</span>  <span class="c1"># Get the dimensions in x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimy</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dimy&#39;</span><span class="p">]</span>  <span class="c1"># Get the dimensions in y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimz</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;dimz&#39;</span><span class="p">]</span>  <span class="c1"># Get the dimensions in z (spectral axis)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimz</span><span class="p">))</span>  <span class="c1"># Complete data cube</span>
        <span class="k">for</span> <span class="n">iquad</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_nb</span><span class="p">)):</span>
            <span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_quadrant_dims</span><span class="p">(</span><span class="n">iquad</span><span class="p">)</span>
            <span class="n">iquad_data</span> <span class="o">=</span> <span class="n">file</span><span class="p">[</span><span class="s1">&#39;quad00</span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">iquad</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">][:]</span>  <span class="c1"># Save data to intermediate array</span>
            <span class="n">iquad_data</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">iquad_data</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)]</span><span class="o">=</span> <span class="mf">1e-22</span> <span class="c1"># Modifs</span>
            <span class="n">iquad_data</span><span class="p">[(</span><span class="n">iquad_data</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e-16</span><span class="p">)]</span><span class="o">=</span> <span class="o">-</span><span class="mf">1e-22</span> <span class="c1"># Modifs</span>
            <span class="n">iquad_data</span><span class="p">[(</span><span class="n">iquad_data</span> <span class="o">&gt;</span> <span class="mf">1e-9</span><span class="p">)]</span><span class="o">=</span> <span class="mf">1e-22</span> <span class="c1"># Modifs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">iquad_data</span>  <span class="c1"># Save to correct location in main cube</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="c1">#.transpose(1, 0, 2)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_header</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_interferometer_angles</span><span class="p">(</span><span class="n">file</span><span class="p">)</span></div>

<div class="viewcode-block" id="Luci.spectrum_axis_func"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.spectrum_axis_func">[docs]</a>    <span class="k">def</span> <span class="nf">spectrum_axis_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the x-axis for the spectra. We must construct this from header information</span>
<span class="sd">        since each pixel only has amplitudes of the spectra at each point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">len_wl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;STEPNB&#39;</span><span class="p">]</span>    <span class="c1"># Length of Spectral Axis</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;CRVAL3&#39;</span><span class="p">]</span>  <span class="c1"># Starting value of the spectral x-axis</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">len_wl</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;CDELT3&#39;</span><span class="p">]</span>  <span class="c1"># End</span>
        <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;CDELT3&#39;</span><span class="p">]</span>  <span class="c1"># Step size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">len_wl</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># Apply redshift correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis_unshifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">len_wl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>  <span class="c1"># Do not apply redshift correction</span></div>

        <span class="c1">#min_ = 1e7  * (self.hdr_dict[&#39;ORDER&#39;] / (2*self.hdr_dict[&#39;STEP&#39;]))# + 1e7  / (2*self.delta_x*self.n_steps)</span>
        <span class="c1">#max_ = 1e7  * ((self.hdr_dict[&#39;ORDER&#39;] + 1) / (2*self.hdr_dict[&#39;STEP&#39;]))# - 1e7  / (2*self.delta_x*self.n_steps)</span>
        <span class="c1">#step_ = max_ - min_</span>
        <span class="c1">#axis = np.array([min_+j*step_/self.hdr_dict[&#39;STEPNB&#39;] for j in range(self.hdr_dict[&#39;STEPNB&#39;])])</span>
        <span class="c1">#self.spectrum_axis = axis#*(1+self.redshift)</span>
        <span class="c1">#self.spectrum_axis_unshifted = axis</span>


<div class="viewcode-block" id="Luci.read_in_reference_spectrum"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.read_in_reference_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">read_in_reference_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read in the reference spectrum that will be used in the machine learning</span>
<span class="sd">        algorithm to interpolate the true spectra so that they</span>
<span class="sd">        wil all have the same size (required for our CNN). The reference spectrum</span>
<span class="sd">        will be saved as self.wavenumbers_syn [cm-1].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_spec</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_spec</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">ref_spec</span><span class="p">:</span>  <span class="c1"># Only want SN3 region</span>
            <span class="n">channel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chan</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">chan</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;SN3&#39;</span><span class="p">:</span>
            <span class="n">min_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span><span class="o">-</span><span class="mi">14700</span><span class="p">))</span>
            <span class="n">max_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span><span class="o">-</span><span class="mi">15600</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;SN2&#39;</span><span class="p">:</span>
            <span class="n">min_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span><span class="o">-</span><span class="mi">19000</span><span class="p">))</span>
            <span class="n">max_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span><span class="o">-</span><span class="mi">21000</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;SN1&#39;</span><span class="p">:</span>
            <span class="n">min_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span><span class="o">-</span><span class="mi">25500</span><span class="p">))</span>
            <span class="n">max_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span><span class="o">-</span><span class="mi">27500</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We do not support this filter.&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Terminating program!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavenumbers_syn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">channel</span><span class="p">[</span><span class="n">min_</span><span class="p">:</span><span class="n">max_</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>


<div class="viewcode-block" id="Luci.read_in_transmission"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.read_in_transmission">[docs]</a>    <span class="k">def</span> <span class="nf">read_in_transmission</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read in the transmission spectrum for the filter. Then apply interpolation</span>
<span class="sd">        on it to make it have the same x-axis as the spectra.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transmission</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/Data/</span><span class="si">%s</span><span class="s1">_filter.dat&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Luci_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">]))</span>  <span class="c1"># first column - axis; second column - value</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">transmission</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">val</span><span class="o">/</span><span class="mi">100</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">transmission</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;slinear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transmission_interpolated</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis_unshifted</span><span class="p">)</span></div>

<div class="viewcode-block" id="Luci.bin_cube"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.bin_cube">[docs]</a>    <span class="k">def</span> <span class="nf">bin_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binning</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to bin cube into bin x bin sub cubes</span>

<span class="sd">        Args:</span>
<span class="sd">            binning: Size of binning (equal in x and y direction)</span>
<span class="sd">            x_min: Lower bound in x</span>
<span class="sd">            x_max: Upper bound in x</span>
<span class="sd">            y_min: Lower bound in y</span>
<span class="sd">            y_max: Upper bound in y</span>
<span class="sd">        Return:</span>
<span class="sd">            Binned cubed called self.cube_binned and new spatial limits</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_shape_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">)</span><span class="o">/</span><span class="n">binning</span><span class="p">)</span>
        <span class="n">y_shape_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)</span><span class="o">/</span><span class="n">binning</span><span class="p">)</span>
        <span class="n">binned_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_shape_new</span><span class="p">,</span> <span class="n">y_shape_new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_shape_new</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y_shape_new</span><span class="p">):</span>
                <span class="n">summed_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="p">[</span><span class="n">x_min</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">binning</span><span class="p">):</span><span class="n">x_min</span><span class="o">+</span><span class="nb">int</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">binning</span><span class="p">),</span> <span class="n">y_min</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">binning</span><span class="p">):</span><span class="n">y_min</span><span class="o">+</span><span class="nb">int</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">binning</span><span class="p">),</span> <span class="p">:]</span>
                <span class="n">summed_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">summed_spec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">summed_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">summed_spec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">binned_cube</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">summed_spec</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span><span class="p">[</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span><span class="p">[</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">binning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span><span class="p">[</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span><span class="p">[</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">binning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span><span class="p">[</span><span class="s1">&#39;CDELT1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span><span class="p">[</span><span class="s1">&#39;CDELT1&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">binning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span><span class="p">[</span><span class="s1">&#39;CDELT2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span><span class="p">[</span><span class="s1">&#39;CDELT2&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">binning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_binned</span> <span class="o">=</span> <span class="n">binned_cube</span> <span class="o">/</span> <span class="p">(</span><span class="n">binning</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>





<div class="viewcode-block" id="Luci.save_fits"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.save_fits">[docs]</a>    <span class="k">def</span> <span class="nf">save_fits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">ampls_fits</span><span class="p">,</span> <span class="n">flux_fits</span><span class="p">,</span> <span class="n">velocities_fits</span><span class="p">,</span> <span class="n">broadenings_fits</span><span class="p">,</span> <span class="n">velocities_errors_fits</span><span class="p">,</span> <span class="n">broadenings_errors_fits</span><span class="p">,</span> <span class="n">chi2_fits</span><span class="p">,</span> <span class="n">continuum_fits</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">binning</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to save the fits files returned from the fitting routine. We save the velocity, broadening,</span>
<span class="sd">        amplitude, flux, and chi-squared maps with the appropriate headers in the output directory</span>
<span class="sd">        defined when the cube is initiated.</span>

<span class="sd">        Args:</span>
<span class="sd">            lines: Lines to fit (e.x. [&#39;Halpha&#39;, &#39;NII6583&#39;])</span>
<span class="sd">            ampls_fits: 3D Numpy array of amplitude values</span>
<span class="sd">            flux_fis: 3D Numpy array of flux values</span>
<span class="sd">            velocities_fits: 3D Numpy array of velocity values</span>
<span class="sd">            broadenings_fits: 3D Numpy array of broadening values</span>
<span class="sd">            velocities_errors_fits: 3D Numpy array of velocity errors</span>
<span class="sd">            broadenings_errors_fits: 3D Numpy array of broadening errors</span>
<span class="sd">            chi2_fits: 2D Numpy array of chi-squared values</span>
<span class="sd">            continuum_fits: 2D Numpy array of continuum value</span>
<span class="sd">            header: Header object (either binned or unbinned)</span>
<span class="sd">            output_name: Output directory and naming convention</span>
<span class="sd">            binning: Value by which to bin (default None)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure output dirs exist for amps, flux, vel, and broad</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/Amplitudes&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/Amplitudes&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/Fluxes&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/Fluxes&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/Velocity&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/Velocity&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/Broadening&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/Broadening&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">object_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">binning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">object_name</span>
        <span class="k">for</span> <span class="n">ct</span><span class="p">,</span><span class="n">line_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>  <span class="c1"># Step through each line to save their individual amplitudes</span>
            <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">+</span> <span class="s1">&#39;/Amplitudes/&#39;</span><span class="o">+</span> <span class="n">output_name</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">line_</span><span class="o">+</span><span class="s1">&#39;_Amplitude.fits&#39;</span><span class="p">,</span> <span class="n">ampls_fits</span><span class="p">[:,:,</span><span class="n">ct</span><span class="p">],</span> <span class="n">header</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">+</span> <span class="s1">&#39;/Fluxes/&#39;</span><span class="o">+</span> <span class="n">output_name</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">line_</span><span class="o">+</span><span class="s1">&#39;_Flux.fits&#39;</span><span class="p">,</span> <span class="n">flux_fits</span><span class="p">[:,:,</span><span class="n">ct</span><span class="p">],</span> <span class="n">header</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">+</span> <span class="s1">&#39;/Velocity/&#39;</span> <span class="o">+</span> <span class="n">output_name</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">line_</span> <span class="o">+</span><span class="s1">&#39;_velocity.fits&#39;</span><span class="p">,</span> <span class="n">velocities_fits</span><span class="p">[:,:,</span><span class="n">ct</span><span class="p">],</span> <span class="n">header</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">+</span> <span class="s1">&#39;/Broadening/&#39;</span> <span class="o">+</span> <span class="n">output_name</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">line_</span> <span class="o">+</span><span class="s1">&#39;_broadening.fits&#39;</span><span class="p">,</span> <span class="n">broadenings_fits</span><span class="p">[:,:,</span><span class="n">ct</span><span class="p">],</span> <span class="n">header</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">+</span> <span class="s1">&#39;/Velocity/&#39;</span> <span class="o">+</span> <span class="n">output_name</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">line_</span> <span class="o">+</span> <span class="s1">&#39;_velocity_err.fits&#39;</span><span class="p">,</span> <span class="n">velocities_errors_fits</span><span class="p">[:,:,</span><span class="n">ct</span><span class="p">],</span> <span class="n">header</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span> <span class="o">+</span> <span class="s1">&#39;/Broadening/&#39;</span> <span class="o">+</span> <span class="n">output_name</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">line_</span> <span class="o">+</span> <span class="s1">&#39;_broadening_err.fits&#39;</span><span class="p">,</span> <span class="n">broadenings_errors_fits</span><span class="p">[:,:,</span><span class="n">ct</span><span class="p">],</span> <span class="n">header</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">output_name</span><span class="o">+</span><span class="s1">&#39;_Chi2.fits&#39;</span><span class="p">,</span> <span class="n">chi2_fits</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">output_name</span><span class="o">+</span><span class="s1">&#39;_continuum.fits&#39;</span><span class="p">,</span> <span class="n">continuum_fits</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Luci.fit_entire_cube"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.fit_entire_cube">[docs]</a>    <span class="k">def</span> <span class="nf">fit_entire_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">fit_function</span><span class="p">,</span> <span class="n">vel_rel</span><span class="p">,</span> <span class="n">sigma_rel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the entire cube (all spatial dimensions)</span>
<span class="sd">        Args:</span>
<span class="sd">            lines: Lines to fit (e.x. [&#39;Halpha&#39;, &#39;NII6583&#39;])</span>
<span class="sd">            fit_function: Fitting function to use (e.x. &#39;gaussian&#39;)</span>
<span class="sd">            vel_rel: Constraints on Velocity/Position (must be list; e.x. [1, 2, 1])</span>
<span class="sd">            sigma_rel: Constraints on sigma (must be list; e.x. [1, 2, 1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_cube</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">fit_function</span><span class="p">,</span><span class="n">vel_rel</span><span class="p">,</span> <span class="n">sigma_rel</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span></div>


<div class="viewcode-block" id="Luci.fit_cube"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.fit_cube">[docs]</a>    <span class="k">def</span> <span class="nf">fit_cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">fit_function</span><span class="p">,</span> <span class="n">vel_rel</span><span class="p">,</span> <span class="n">sigma_rel</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bayes_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uncertainty_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Primary fit call to fit rectangular regions in the data cube. This wraps the</span>
<span class="sd">        LuciFits.FIT().fit() call which applies all the fitting steps. This also</span>
<span class="sd">        saves the velocity and broadening fits files.</span>

<span class="sd">        Args:</span>
<span class="sd">            lines: Lines to fit (e.x. [&#39;Halpha&#39;, &#39;NII6583&#39;])</span>
<span class="sd">            fit_function: Fitting function to use (e.x. &#39;gaussian&#39;)</span>
<span class="sd">            vel_rel: Constraints on Velocity/Position (must be list; e.x. [1, 2, 1])</span>
<span class="sd">            sigma_rel: Constraints on sigma (must be list; e.x. [1, 2, 1])</span>
<span class="sd">            x_min: Lower bound in x</span>
<span class="sd">            x_max: Upper bound in x</span>
<span class="sd">            y_min: Lower bound in y</span>
<span class="sd">            y_max: Upper bound in y</span>
<span class="sd">            bkg: Background Spectrum (1D numpy array; default None)</span>
<span class="sd">            binning:  Value by which to bin (default None)</span>
<span class="sd">            bayes_bool: Boolean to determine whether or not to run Bayesian analysis (default False)</span>
<span class="sd">            output_name: User defined output path/name (default None)</span>
<span class="sd">            uncertainty_bool: Boolean to determine whether or not to run the uncertainty analysis (default False)</span>
<span class="sd">        Return:</span>
<span class="sd">            Velocity and Broadening arrays (2d). Also return amplitudes array (3D).</span>

<span class="sd">        Examples:</span>
<span class="sd">            As always, we must first have the cube initialized (see basic example).</span>

<span class="sd">            If we want to fit all five lines in SN3 with a sincgauss function and binning of 2</span>
<span class="sd">            over a rectangular region defined in image coordinates as 800&lt;x&lt;1500; 250&lt;y&lt;1250,</span>
<span class="sd">            we would run the following:</span>

<span class="sd">            &gt;&gt;&gt; vel_map, broad_map, flux_map, chi2_fits = cube.fit_cube([&#39;Halpha&#39;, &#39;NII6548&#39;, &#39;NII6583&#39;, &#39;SII6716&#39;, &#39;SII6731&#39;], &#39;sincgauss&#39;, 800, 1500, 250, 750, binning=2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize fit solution arrays</span>
        <span class="k">if</span> <span class="n">binning</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">binning</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_cube</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
            <span class="c1">#x_min_bin = int(x_min/binning) ; y_min_bin = int(y_min/binning) ; x_max_bin = int(x_max/binning) ;  y_max_bin = int(y_max/binning)</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">)</span><span class="o">/</span><span class="n">binning</span><span class="p">)</span> <span class="p">;</span>  <span class="n">y_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)</span><span class="o">/</span><span class="n">binning</span><span class="p">)</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">chi2_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">corr_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">step_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># First two dimensions are the X and Y dimensions.</span>
        <span class="c1">#The third dimension corresponds to the line in the order of the lines input parameter.</span>
        <span class="n">ampls_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">flux_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">velocities_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">broadenings_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">velocities_errors_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">broadenings_errors_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">continuum_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1">#if output_name == None:</span>
            <span class="c1">#output_name = self.output_dir+&#39;/&#39;+self.object_name</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)):</span>
            <span class="n">y_pix</span> <span class="o">=</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">i</span>
            <span class="n">ampls_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">flux_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vels_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">broads_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vels_errs_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">broads_errs_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">chi2_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">corr_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">step_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">continuum_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">):</span>
                <span class="n">x_pix</span> <span class="o">=</span> <span class="n">x_min</span><span class="o">+</span><span class="n">j</span>
                <span class="k">if</span> <span class="n">binning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_binned</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="n">bkg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">binning</span><span class="p">:</span>
                        <span class="n">sky</span> <span class="o">-=</span> <span class="n">bkg</span> <span class="o">*</span> <span class="n">binning</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Subtract background spectrum</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sky</span> <span class="o">-=</span> <span class="n">bkg</span>  <span class="c1"># Subtract background spectrum</span>
                <span class="n">good_sky_inds</span> <span class="o">=</span> <span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sky</span><span class="p">)]</span>  <span class="c1"># Clean up spectrum</span>
                <span class="n">sky</span> <span class="o">=</span> <span class="n">sky</span><span class="p">[</span><span class="n">good_sky_inds</span><span class="p">]</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span><span class="p">[</span><span class="n">good_sky_inds</span><span class="p">]</span>
                <span class="c1"># Call fit!</span>
                <span class="n">fit</span> <span class="o">=</span> <span class="n">Fit</span><span class="p">(</span><span class="n">sky</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavenumbers_syn</span><span class="p">,</span> <span class="n">fit_function</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">vel_rel</span><span class="p">,</span> <span class="n">sigma_rel</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">model_ML</span><span class="p">,</span> <span class="n">trans_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_interpolated</span><span class="p">,</span>
                        <span class="n">theta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interferometer_theta</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">],</span>
                        <span class="n">delta_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;STEP&#39;</span><span class="p">],</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;STEPNB&#39;</span><span class="p">],</span>
                        <span class="nb">filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">],</span>
                        <span class="n">bayes_bool</span><span class="o">=</span><span class="n">bayes_bool</span><span class="p">,</span> <span class="n">uncertainty_bool</span><span class="o">=</span><span class="n">uncertainty_bool</span><span class="p">)</span>
                <span class="n">fit_dict</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
                <span class="c1"># Save local list of fit values</span>
                <span class="n">ampls_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;amplitudes&#39;</span><span class="p">])</span>
                <span class="n">flux_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;fluxes&#39;</span><span class="p">])</span>
                <span class="n">vels_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;velocities&#39;</span><span class="p">])</span>
                <span class="n">broads_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;sigmas&#39;</span><span class="p">])</span>
                <span class="n">vels_errs_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;vels_errors&#39;</span><span class="p">])</span>
                <span class="n">broads_errs_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;sigmas_errors&#39;</span><span class="p">])</span>
                <span class="n">chi2_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;chi2&#39;</span><span class="p">])</span>
                <span class="n">corr_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;corr&#39;</span><span class="p">])</span>
                <span class="n">step_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;axis_step&#39;</span><span class="p">])</span>
                <span class="n">continuum_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;continuum&#39;</span><span class="p">])</span>
            <span class="c1"># Update global array of fit values</span>
            <span class="n">ampls_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ampls_local</span>
            <span class="n">flux_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_local</span>
            <span class="n">velocities_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vels_local</span>
            <span class="n">broadenings_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">broads_local</span>
            <span class="n">velocities_errors_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vels_errs_local</span>
            <span class="n">broadenings_errors_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">broads_errs_local</span>
            <span class="n">chi2_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chi2_local</span>
            <span class="n">corr_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr_local</span>
            <span class="n">step_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">step_local</span>
            <span class="n">continuum_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">continuum_local</span>
        <span class="c1"># Write outputs (Velocity, Broadening, and Amplitudes)</span>
        <span class="k">if</span> <span class="n">binning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check if deep image exists: if not, create it</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="o">+</span><span class="s1">&#39;_deep.fits&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_deep_image</span><span class="p">()</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check if deep image exists: if not, create it</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="o">+</span><span class="s1">&#39;_deep.fits&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">create_deep_image</span><span class="p">()</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="n">naxis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">cutout</span> <span class="o">=</span> <span class="n">Cutout2D</span><span class="p">(</span><span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="o">+</span><span class="s1">&#39;_deep.fits&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="p">((</span><span class="n">x_max</span><span class="o">+</span><span class="n">x_min</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">y_max</span><span class="o">+</span><span class="n">y_min</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_fits</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">ampls_fits</span><span class="p">,</span> <span class="n">flux_fits</span><span class="p">,</span> <span class="n">velocities_fits</span><span class="p">,</span> <span class="n">broadenings_fits</span><span class="p">,</span> <span class="n">velocities_errors_fits</span><span class="p">,</span> <span class="n">broadenings_errors_fits</span><span class="p">,</span> <span class="n">chi2_fits</span><span class="p">,</span> <span class="n">continuum_fits</span><span class="p">,</span> <span class="n">cutout</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">to_header</span><span class="p">(),</span> <span class="n">binning</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">velocities_fits</span><span class="p">,</span> <span class="n">broadenings_fits</span><span class="p">,</span> <span class="n">flux_fits</span><span class="p">,</span> <span class="n">chi2_fits</span></div>

        <span class="c1">#n_threads = 1</span>
        <span class="c1">#for i in range(x_max-x_min):</span>
            <span class="c1">#SNR_calc(VEL, BROAD, i)</span>
        <span class="c1">#Parallel(n_jobs=n_threads, backend=&quot;threading&quot;, batch_size=int((x_max-x_min)/n_threads))(delayed(SNR_calc)(VEL, BROAD, i) for i in range(x_max-x_min));</span>
        <span class="c1">#Parallel(n_jobs=n_threads, backend=&quot;threading&quot;)(delayed(SNR_calc)(VEL, BROAD, i) for i in tqdm(range(x_max-x_min)));</span>

<div class="viewcode-block" id="Luci.fit_region"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.fit_region">[docs]</a>    <span class="k">def</span> <span class="nf">fit_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">fit_function</span><span class="p">,</span> <span class="n">vel_rel</span><span class="p">,</span> <span class="n">sigma_rel</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bayes_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uncertainty_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the spectrum in a region. This is an extremely similar command to fit_cube except</span>
<span class="sd">        it works for ds9 regions. We first create a mask from the ds9 region file. Then</span>
<span class="sd">        we step through the cube and only fit the unmasked pixels. Although this may not</span>
<span class="sd">        be the most efficient method, it does ensure the fidelity of the wcs system.</span>

<span class="sd">        Args:</span>
<span class="sd">            lines: Lines to fit (e.x. [&#39;Halpha&#39;, &#39;NII6583&#39;])</span>
<span class="sd">            fit_function: Fitting function to use (e.x. &#39;gaussian&#39;)</span>
<span class="sd">            vel_rel: Constraints on Velocity/Position (must be list; e.x. [1, 2])</span>
<span class="sd">            sigma_rel: Constraints on sigma (must be list; e.x. [1, 2])</span>
<span class="sd">            region: Name of ds9 region file (e.x. &#39;region.reg&#39;). You can also pass a boolean mask array.</span>
<span class="sd">            bkg: Background Spectrum (1D numpy array; default None)</span>
<span class="sd">            binning:  Value by which to bin (default None)</span>
<span class="sd">            bayes_bool: Boolean to determine whether or not to run Bayesian analysis (default False)</span>
<span class="sd">            output_name: User defined output path/name</span>
<span class="sd">            uncertainty_bool: Boolean to determine whether or not to run the uncertainty analysis (default False)</span>
<span class="sd">        Return:</span>
<span class="sd">            Velocity and Broadening arrays (2d). Also return amplitudes array (3D).</span>

<span class="sd">        Examples:</span>
<span class="sd">            As always, we must first have the cube initialized (see basic example).</span>

<span class="sd">            If we want to fit all five lines in SN3 with a gaussian function and no binning</span>
<span class="sd">            over a ds9 region called main.reg, we would run the following:</span>

<span class="sd">            &gt;&gt;&gt; vel_map, broad_map, flux_map, chi2_fits = cube.fit_region([&#39;Halpha&#39;, &#39;NII6548&#39;, &#39;NII6583&#39;, &#39;SII6716&#39;, &#39;SII6731&#39;], &#39;gaussian&#39;, region=&#39;main.reg&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set spatial bounds for entire cube</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Initialize fit solution arrays</span>
        <span class="k">if</span> <span class="n">binning</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">binning</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_cube</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
            <span class="c1">#x_min = int(x_min/binning) ; y_min = int(y_min/binning) ; x_max = int(x_max/binning) ;  y_max = int(y_max/binning)</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">)</span><span class="o">/</span><span class="n">binning</span><span class="p">)</span> <span class="p">;</span>  <span class="n">y_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)</span><span class="o">/</span><span class="n">binning</span><span class="p">)</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Create mask</span>
        <span class="k">if</span> <span class="s1">&#39;.reg&#39;</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2064</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span><span class="c1">#(self.header[&quot;NAXIS1&quot;], self.header[&quot;NAXIS2&quot;])  # Get the shape</span>
            <span class="k">if</span> <span class="n">binning</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">binning</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span>
            <span class="n">header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">,</span> <span class="mi">2064</span><span class="p">)</span>
            <span class="n">header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">pyregion</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">region</span><span class="p">)</span><span class="o">.</span><span class="n">as_imagecoord</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>  <span class="c1"># Obtain pyregion region</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Calculate mask from pyregion region</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># If numpy .np file</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">region</span>
        <span class="c1"># Clean up output name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># If region file is a path, just keep the name for output purposes</span>
                <span class="n">region</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">output_name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">region</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Passed mask not region file</span>
            <span class="k">if</span> <span class="n">output_name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="o">+</span><span class="s1">&#39;_mask&#39;</span>

        <span class="n">chi2_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">corr_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">step_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># First two dimensions are the X and Y dimensions.</span>
        <span class="c1">#The third dimension corresponds to the line in the order of the lines input parameter.</span>
        <span class="n">ampls_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">flux_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">velocities_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">broadenings_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">velocities_errors_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">broadenings_errors_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">continuum_fits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)):</span>
            <span class="n">y_pix</span> <span class="o">=</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">i</span>
            <span class="n">ampls_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">flux_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vels_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">broads_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vels_errs_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">broads_errs_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">chi2_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">continuum_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">):</span>
                <span class="n">x_pix</span> <span class="o">=</span> <span class="n">x_min</span><span class="o">+</span><span class="n">j</span>
                <span class="c1"># Check if pixel is in the mask or not</span>
                <span class="c1"># If so, fit as normal. Else, set values to zero</span>
                <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">binning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">sky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_binned</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="k">if</span> <span class="n">bkg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">binning</span><span class="p">:</span>
                            <span class="n">sky</span> <span class="o">-=</span> <span class="n">bkg</span> <span class="o">*</span> <span class="n">binning</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Subtract background spectrum</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">sky</span> <span class="o">-=</span> <span class="n">bkg</span>  <span class="c1"># Subtract background spectrum</span>
                    <span class="n">ct</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">good_sky_inds</span> <span class="o">=</span> <span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sky</span><span class="p">)]</span>  <span class="c1"># Clean up spectrum</span>
                    <span class="n">sky</span> <span class="o">=</span> <span class="n">sky</span><span class="p">[</span><span class="n">good_sky_inds</span><span class="p">]</span>
                    <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span><span class="p">[</span><span class="n">good_sky_inds</span><span class="p">]</span>
                    <span class="c1"># Call fit!</span>
                    <span class="n">fit</span> <span class="o">=</span> <span class="n">Fit</span><span class="p">(</span><span class="n">sky</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavenumbers_syn</span><span class="p">,</span> <span class="n">fit_function</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">vel_rel</span><span class="p">,</span> <span class="n">sigma_rel</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">model_ML</span><span class="p">,</span> <span class="n">trans_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_interpolated</span><span class="p">,</span>
                            <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interferometer_theta</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">],</span>
                            <span class="n">delta_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;CDELT3&#39;</span><span class="p">],</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;STEPNB&#39;</span><span class="p">],</span>
                            <span class="nb">filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">],</span>
                            <span class="n">bayes_bool</span><span class="o">=</span><span class="n">bayes_bool</span><span class="p">,</span> <span class="n">uncertainty_bool</span><span class="o">=</span><span class="n">uncertainty_bool</span><span class="p">)</span>
                    <span class="n">fit_dict</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
                    <span class="c1"># Save local list of fit values</span>
                    <span class="n">ampls_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;amplitudes&#39;</span><span class="p">])</span>
                    <span class="n">flux_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;fluxes&#39;</span><span class="p">])</span>
                    <span class="n">vels_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;velocities&#39;</span><span class="p">])</span>
                    <span class="n">broads_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;sigmas&#39;</span><span class="p">])</span>
                    <span class="n">vels_errs_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;vels_errors&#39;</span><span class="p">])</span>
                    <span class="n">broads_errs_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;sigmas_errors&#39;</span><span class="p">])</span>
                    <span class="n">chi2_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;chi2&#39;</span><span class="p">])</span>
                    <span class="n">continuum_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;continuum&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If outside of mask set to zero</span>
                    <span class="n">ampls_local</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
                    <span class="n">flux_local</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
                    <span class="n">vels_local</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
                    <span class="n">broads_local</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
                    <span class="n">vels_errs_local</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
                    <span class="n">broads_errs_local</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
                    <span class="n">chi2_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">continuum_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Update global array of fit values</span>
            <span class="n">ampls_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ampls_local</span>
            <span class="n">flux_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_local</span>
            <span class="n">velocities_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vels_local</span>
            <span class="n">broadenings_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">broads_local</span>
            <span class="n">velocities_errors_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vels_errs_local</span>
            <span class="n">broadenings_errors_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">broads_errs_local</span>
            <span class="n">chi2_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chi2_local</span>
            <span class="n">continuum_fits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">continuum_local</span>
        <span class="c1"># Write outputs (Velocity, Broadening, and Amplitudes)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">binning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header_binned</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wcs</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="n">cutout</span> <span class="o">=</span> <span class="n">Cutout2D</span><span class="p">(</span><span class="n">velocities_fits</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="o">=</span><span class="p">((</span><span class="n">x_max</span><span class="o">+</span><span class="n">x_min</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">y_max</span><span class="o">+</span><span class="n">y_min</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">wcs</span><span class="o">=</span><span class="n">wcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_fits</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">ampls_fits</span><span class="p">,</span> <span class="n">flux_fits</span><span class="p">,</span> <span class="n">velocities_fits</span><span class="p">,</span> <span class="n">broadenings_fits</span><span class="p">,</span> <span class="n">velocities_errors_fits</span><span class="p">,</span> <span class="n">broadenings_errors_fits</span><span class="p">,</span> <span class="n">chi2_fits</span><span class="p">,</span> <span class="n">continuum_fits</span><span class="p">,</span> <span class="n">cutout</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">to_header</span><span class="p">(),</span> <span class="n">binning</span><span class="p">)</span>


        <span class="k">return</span> <span class="n">velocities_fits</span><span class="p">,</span> <span class="n">broadenings_fits</span><span class="p">,</span> <span class="n">flux_fits</span><span class="p">,</span> <span class="n">chi2_fits</span><span class="p">,</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="Luci.extract_spectrum"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.extract_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">extract_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract spectrum in region. This is primarily used to extract background regions.</span>
<span class="sd">        The spectra in the region are summed and then averaged (if mean is selected).</span>
<span class="sd">        Using the &#39;mean&#39; argument, we can either calculate the total summed spectrum (False)</span>
<span class="sd">        or the averaged spectrum for background spectra (True).</span>

<span class="sd">        Args:</span>
<span class="sd">            x_min: Lower bound in x</span>
<span class="sd">            x_max: Upper bound in x</span>
<span class="sd">            y_min: Lower bound in y</span>
<span class="sd">            y_max: Upper bound in y</span>
<span class="sd">            bkg: Background Spectrum (1D numpy array; default None)</span>
<span class="sd">            binning:  Value by which to bin (default None)</span>
<span class="sd">            mean: Boolean to determine whether or not the mean spectrum is taken. This is used for calculating background spectra.</span>
<span class="sd">        Return:</span>
<span class="sd">            X-axis and spectral axis of region.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">integrated_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">spec_ct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Initialize fit solution arrays</span>
        <span class="k">if</span> <span class="n">binning</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_cube</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
            <span class="c1">#x_min = int(x_min/binning) ; y_min = int(y_min/binning) ; x_max = int(x_max/binning) ;  y_max = int(y_max/binning)</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">)</span><span class="o">/</span><span class="n">binning</span><span class="p">)</span> <span class="p">;</span>  <span class="n">y_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)</span><span class="o">/</span><span class="n">binning</span><span class="p">)</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)):</span>
            <span class="n">y_pix</span> <span class="o">=</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">i</span>
            <span class="n">vel_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">broad_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ampls_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">flux_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">chi2_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">):</span>
                <span class="n">x_pix</span> <span class="o">=</span> <span class="n">x_min</span><span class="o">+</span><span class="n">j</span>
                <span class="k">if</span> <span class="n">binning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_binned</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="n">bkg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">binning</span><span class="p">:</span>
                        <span class="n">sky</span> <span class="o">-=</span> <span class="n">bkg</span> <span class="o">*</span> <span class="n">binning</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Subtract background spectrum</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sky</span> <span class="o">-=</span> <span class="n">bkg</span>  <span class="c1"># Subtract background spectrum</span>
                <span class="n">good_sky_inds</span> <span class="o">=</span> <span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sky</span><span class="p">)]</span>  <span class="c1"># Clean up spectrum</span>
                <span class="n">integrated_spectrum</span> <span class="o">+=</span> <span class="n">sky</span><span class="p">[</span><span class="n">good_sky_inds</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">spec_ct</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span><span class="p">[</span><span class="n">good_sky_inds</span><span class="p">]</span>
                    <span class="n">spec_ct</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">mean</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">integrated_spectrum</span> <span class="o">/=</span> <span class="n">spec_ct</span>
        <span class="k">return</span> <span class="n">axis</span><span class="p">,</span> <span class="n">integrated_spectrum</span></div>


<div class="viewcode-block" id="Luci.extract_spectrum_region"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.extract_spectrum_region">[docs]</a>    <span class="k">def</span> <span class="nf">extract_spectrum_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract spectrum in region. This is primarily used to extract background regions.</span>
<span class="sd">        The spectra in the region are summed and then averaged (if mean is selected).</span>
<span class="sd">        Using the &#39;mean&#39; argument, we can either calculate the total summed spectrum (False)</span>
<span class="sd">        or the averaged spectrum for background spectra (True).</span>

<span class="sd">        Args:</span>
<span class="sd">            region: Name of ds9 region file (e.x. &#39;region.reg&#39;). You can also pass a boolean mask array.</span>
<span class="sd">            mean: Boolean to determine whether or not the mean spectrum is taken. This is used for calculating background spectra.</span>
<span class="sd">        Return:</span>
<span class="sd">            X-axis and spectral axis of region.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create mask</span>
        <span class="k">if</span> <span class="s1">&#39;.reg&#39;</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2064</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span><span class="c1">#(self.header[&quot;NAXIS1&quot;], self.header[&quot;NAXIS2&quot;])  # Get the shape</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">pyregion</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">region</span><span class="p">)</span><span class="o">.</span><span class="n">as_imagecoord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>  <span class="c1"># Obtain pyregion region</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Calculate mask from pyregion region</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">region</span>
        <span class="c1"># Set spatial bounds for entire cube</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">integrated_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">spec_ct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)):</span>
            <span class="n">y_pix</span> <span class="o">=</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">):</span>
                <span class="n">x_pix</span> <span class="o">=</span> <span class="n">x_min</span><span class="o">+</span><span class="n">j</span>
                <span class="c1"># Check if pixel is in the mask or not</span>
                <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">integrated_spectrum</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">spec_ct</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">if</span> <span class="n">mean</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">integrated_spectrum</span> <span class="o">/=</span> <span class="n">spec_ct</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span><span class="p">,</span> <span class="n">integrated_spectrum</span></div>



<div class="viewcode-block" id="Luci.fit_spectrum_region"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.fit_spectrum_region">[docs]</a>    <span class="k">def</span> <span class="nf">fit_spectrum_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">fit_function</span><span class="p">,</span> <span class="n">vel_rel</span><span class="p">,</span> <span class="n">sigma_rel</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bayes_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">uncertainty_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit spectrum in region.</span>
<span class="sd">        The spectra in the region are summed and then averaged (if mean is selected).</span>
<span class="sd">        Using the &#39;mean&#39; argument, we can either calculate the total summed spectrum (False)</span>
<span class="sd">        or the averaged spectrum for background spectra (True).</span>

<span class="sd">        Args:</span>
<span class="sd">            lines: Lines to fit (e.x. [&#39;Halpha&#39;, &#39;NII6583&#39;])</span>
<span class="sd">            fit_function: Fitting function to use (e.x. &#39;gaussian&#39;)</span>
<span class="sd">            vel_rel: Constraints on Velocity/Position (must be list; e.x. [1, 2, 1])</span>
<span class="sd">            sigma_rel: Constraints on sigma (must be list; e.x. [1, 2, 1])</span>
<span class="sd">            region: Name of ds9 region file (e.x. &#39;region.reg&#39;). You can also pass a boolean mask array.</span>
<span class="sd">            bkg: Background Spectrum (1D numpy array; default None)</span>
<span class="sd">            bayes_bool: Boolean to determine whether or not to run Bayesian analysis</span>

<span class="sd">        Return:</span>
<span class="sd">            X-axis and spectral axis of region.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create mask</span>
        <span class="k">if</span> <span class="s1">&#39;.reg&#39;</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2064</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span><span class="c1">#(self.header[&quot;NAXIS1&quot;], self.header[&quot;NAXIS2&quot;])  # Get the shape</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">pyregion</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">region</span><span class="p">)</span><span class="o">.</span><span class="n">as_imagecoord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>  <span class="c1"># Obtain pyregion region</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Calculate mask from pyregion region</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">region</span>
        <span class="c1"># Set spatial bounds for entire cube</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">integrated_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">spec_ct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">)):</span>
            <span class="n">y_pix</span> <span class="o">=</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">):</span>
                <span class="n">x_pix</span> <span class="o">=</span> <span class="n">x_min</span><span class="o">+</span><span class="n">j</span>
                <span class="c1"># Check if pixel is in the mask or not</span>
                <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">integrated_spectrum</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">spec_ct</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">if</span> <span class="n">mean</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">integrated_spectrum</span> <span class="o">/=</span> <span class="n">spec_ct</span>
        <span class="k">if</span> <span class="n">bkg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">integrated_spectrum</span> <span class="o">-=</span> <span class="n">bkg</span>  <span class="c1"># Subtract background spectrum</span>
        <span class="n">good_sky_inds</span> <span class="o">=</span> <span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">integrated_spectrum</span><span class="p">)]</span>  <span class="c1"># Clean up spectrum</span>
        <span class="n">sky</span> <span class="o">=</span> <span class="n">integrated_spectrum</span><span class="p">[</span><span class="n">good_sky_inds</span><span class="p">]</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span><span class="p">[</span><span class="n">good_sky_inds</span><span class="p">]</span>
        <span class="c1"># Call fit!</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">Fit</span><span class="p">(</span><span class="n">sky</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavenumbers_syn</span><span class="p">,</span> <span class="n">fit_function</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">vel_rel</span><span class="p">,</span> <span class="n">sigma_rel</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model_ML</span><span class="p">,</span> <span class="n">trans_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_interpolated</span><span class="p">,</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interferometer_theta</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">],</span>
                <span class="n">delta_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;CDELT3&#39;</span><span class="p">],</span> <span class="n">n_steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;STEPNB&#39;</span><span class="p">],</span>
                <span class="nb">filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">],</span>
                <span class="n">bayes_bool</span><span class="o">=</span><span class="n">bayes_bool</span><span class="p">,</span> <span class="n">uncertainty_bool</span><span class="o">=</span><span class="n">uncertainty_bool</span><span class="p">)</span>
        <span class="n">fit_dict</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">axis</span><span class="p">,</span> <span class="n">sky</span><span class="p">,</span> <span class="n">fit_dict</span></div>



<div class="viewcode-block" id="Luci.create_snr_map"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.create_snr_map">[docs]</a>    <span class="k">def</span> <span class="nf">create_snr_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">y_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_max</span><span class="o">=</span><span class="mi">2064</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create signal-to-noise ratio (SNR) map of a given region. If no bounds are given,</span>
<span class="sd">        a map of the entire cube is calculated.</span>

<span class="sd">        Args:</span>
<span class="sd">            x_min: Minimal X value (default 0)</span>
<span class="sd">            x_max: Maximal X value (default 2048)</span>
<span class="sd">            y_min: Minimal Y value (default 0)</span>
<span class="sd">            y_max: Maximal Y value (default 2064)</span>
<span class="sd">            method: Method used to calculate SNR (default 1; options 1 or 2)</span>
<span class="sd">        Return:</span>
<span class="sd">            snr_map: Signal-to-Noise ratio map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate bounds for SNR calculation</span>
        <span class="c1"># Step through spectra</span>
        <span class="n">SNR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1">#start = time.time()</span>
        <span class="c1">#def SNR_calc(SNR, i):</span>
        <span class="n">flux_min</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">flux_max</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">noise_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">noise_max</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Initializing bounds for flux and noise calculation regions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;SN3&#39;</span><span class="p">:</span>
            <span class="n">flux_min</span> <span class="o">=</span> <span class="mi">15150</span><span class="p">;</span> <span class="n">flux_max</span> <span class="o">=</span> <span class="mi">15300</span><span class="p">;</span> <span class="n">noise_min</span> <span class="o">=</span> <span class="mi">16000</span><span class="p">;</span> <span class="n">noise_max</span> <span class="o">=</span> <span class="mi">16400</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdr_dict</span><span class="p">[</span><span class="s1">&#39;FILTER&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;SN1&#39;</span><span class="p">:</span>
            <span class="n">flux_min</span> <span class="o">=</span> <span class="mi">26550</span><span class="p">;</span> <span class="n">flux_max</span> <span class="o">=</span> <span class="mi">27550</span><span class="p">;</span> <span class="n">noise_min</span> <span class="o">=</span> <span class="mi">25300</span><span class="p">;</span> <span class="n">noise_max</span> <span class="o">=</span> <span class="mi">25700</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SNR Calculation for this filter has not been implemented&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y_max</span><span class="o">-</span><span class="n">y_min</span><span class="p">):</span>
            <span class="n">y_pix</span> <span class="o">=</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">i</span>
            <span class="n">snr_local</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">):</span>
                <span class="n">x_pix</span> <span class="o">=</span> <span class="n">x_min</span><span class="o">+</span><span class="n">j</span>
                <span class="c1"># Calculate SNR</span>
                <span class="c1"># Select spectral region around Halpha and NII complex</span>
                <span class="n">min_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span><span class="p">)</span><span class="o">-</span><span class="n">flux_min</span><span class="p">))</span>
                <span class="n">max_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span><span class="p">)</span><span class="o">-</span><span class="n">flux_max</span><span class="p">))</span>
                <span class="n">flux_in_region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">,</span> <span class="n">min_</span><span class="p">:</span><span class="n">max_</span><span class="p">])</span>
                <span class="c1"># Select distance region</span>
                <span class="n">min_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span><span class="p">)</span><span class="o">-</span><span class="n">noise_min</span><span class="p">))</span>
                <span class="n">max_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum_axis</span><span class="p">)</span><span class="o">-</span><span class="n">noise_max</span><span class="p">))</span>
                <span class="n">std_out_region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cube_final</span><span class="p">[</span><span class="n">x_pix</span><span class="p">,</span> <span class="n">y_pix</span><span class="p">,</span> <span class="n">min_</span><span class="p">:</span><span class="n">max_</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">flux_in_region</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">flux_in_region</span><span class="p">)</span>
                    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">std_out_region</span><span class="p">)</span>
                    <span class="n">snr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">signal</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise</span><span class="p">))</span>
                    <span class="n">snr</span> <span class="o">=</span> <span class="n">snr</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">flux_in_region</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">snr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">flux_in_region</span><span class="o">/</span><span class="n">std_out_region</span><span class="p">)</span>
                    <span class="n">snr</span> <span class="o">=</span> <span class="n">snr</span>
                <span class="n">snr_local</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">snr</span><span class="p">)</span>
            <span class="n">SNR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">snr_local</span>
        <span class="c1">#n_threads = 2</span>
        <span class="c1">#Parallel(n_jobs=n_threads, backend=&quot;threading&quot;, batch_size=int((x_max-x_min)/n_threads))(delayed(SNR_calc)(SNR,i) for i in tqdm(range(x_max-x_min)));</span>
        <span class="c1">#end = time.time()</span>
        <span class="c1"># Save</span>
        <span class="n">fits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="o">+</span><span class="s1">&#39;_SNR.fits&#39;</span><span class="p">,</span> <span class="n">SNR</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<div class="viewcode-block" id="Luci.update_astrometry"><a class="viewcode-back" href="../../api/LUCI.html#LUCI.LuciBase.Luci.update_astrometry">[docs]</a>    <span class="k">def</span> <span class="nf">update_astrometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use astronomy.net to update the astrometry in the header</span>
<span class="sd">        If astronomy.net successfully finds the corrected astrononmy, the self.header is updated. Otherwise,</span>
<span class="sd">        the header is not updated and an exception is thrown.</span>

<span class="sd">        Args:</span>
<span class="sd">            api_key: Astronomy.net user api key</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initiate Astronomy Net</span>
        <span class="n">ast</span> <span class="o">=</span> <span class="n">AstrometryNet</span><span class="p">()</span>
        <span class="n">ast</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">api_key</span>
        <span class="n">ast</span><span class="o">.</span><span class="n">api_key</span> <span class="o">=</span> <span class="n">api_key</span>
        <span class="n">try_again</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">submission_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Check that deep image exists. Otherwise make one</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="o">+</span><span class="s1">&#39;_deep.fits&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_deep_image</span><span class="p">()</span>
        <span class="c1"># Now submit to astronomy.net until the value is found</span>
        <span class="k">while</span> <span class="n">try_again</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">submission_id</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">wcs_header</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">solve_from_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="o">+</span><span class="s1">&#39;_deep.fits&#39;</span><span class="p">,</span> <span class="n">submission_id</span><span class="o">=</span><span class="n">submission_id</span><span class="p">,</span> <span class="n">solve_timeout</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span><span class="c1">#, use_sextractor=True, center_ra=float(ra), center_dec=float(dec))</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Timedout&quot;</span><span class="p">)</span>
                    <span class="n">submission_id</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># got a result, so terminate</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result&quot;</span><span class="p">)</span>
                    <span class="n">try_again</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">wcs_header</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">monitor_submission</span><span class="p">(</span><span class="n">submission_id</span><span class="p">,</span> <span class="n">solve_timeout</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Timedout&quot;</span><span class="p">)</span>
                    <span class="n">submission_id</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># got a result, so terminate</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result&quot;</span><span class="p">)</span>
                    <span class="n">try_again</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">wcs_header</span><span class="p">:</span>
            <span class="c1"># Code to execute when solve succeeds</span>
            <span class="c1"># update deep image header</span>
            <span class="n">deep</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">object_name</span><span class="o">+</span><span class="s1">&#39;_deep.fits&#39;</span><span class="p">)</span>
            <span class="n">deep</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">wcs_header</span><span class="p">)</span>
            <span class="n">deep</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="c1"># Update normal header</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">wcs_header</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Code to execute when solve fails</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Astronomy.net failed to solve. This astrometry has not been updated!&#39;</span><span class="p">)</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">LUCI-package</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/modules.html">Module Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Carter Rhea.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>